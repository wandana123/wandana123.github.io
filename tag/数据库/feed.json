{
    "version": "https://jsonfeed.org/version/1",
    "title": "全栈技术 • All posts by \"数据库\" tag",
    "description": "",
    "home_page_url": "https://wandana123.github.io",
    "items": [
        {
            "id": "https://wandana123.github.io/2024/07/24/sql%E3%81%AEoracle%E8%A1%A8%E7%A9%BA%E9%97%B4%E6%89%A9%E5%AE%B9/",
            "url": "https://wandana123.github.io/2024/07/24/sql%E3%81%AEoracle%E8%A1%A8%E7%A9%BA%E9%97%B4%E6%89%A9%E5%AE%B9/",
            "title": "sqlのoracle表空间扩容",
            "date_published": "2024-07-24T07:37:37.000Z",
            "content_html": "<p>业务场景：</p>\n<p>记录一下，2024 年 7 月 24，发生了一场不大不小的生产事故，导致一个地级市整个城市的某个业务系统停服一上午。也吸取一下深刻的教训。简单来讲，导致该事故最直接的原因就是这个业务系统现场人员为按时巡检导致，该系统数据库表空间满了没人知道，直到客户反馈业务传输有问题了，才开始排查，排查发现录入的信息数据库内无法查找，抽取日志查看发现表空间无法自动扩容。<br>\n所以运维工作中，日常巡检的必要性还是毋庸置疑的。</p>\n<p>扩容用有 dba 权限的账号，通过 plsql 客户端直接操作的。是使用增加数据文件的方式进行扩容。<strong>建议表空间超过 90% 就直接扩容</strong>。</p>\n<p>–查询表空间使用情况<br>\n <code>SELECT a.tablespace_name &quot;表空间名&quot;,        round(total / (1024 * 1024 * 1024), 2) &quot;表空间大小(G)&quot;,        round(free / (1024 * 1024 * 1024), 2) &quot;表空间剩余大小(G)&quot;,        round((total - free) / (1024 * 1024 * 1024), 2) &quot;表空间使用大小(G)&quot;,        round((total - free) / total, 4) * 100 &quot;使用率 %&quot;   FROM (SELECT tablespace_name, SUM(bytes) free           FROM dba_free_space          GROUP BY tablespace_name) a,        (SELECT tablespace_name, SUM(bytes) total           FROM dba_data_files          GROUP BY tablespace_name) b  WHERE a.tablespace_name = b.tablespace_name</code></p>\n<p>–临时表空间使用率<br>\n <code>select c.tablespace_name &quot;临时表空间名&quot;,        round(c.bytes / 1024 / 1024 / 1024, 2) &quot;临时表空间大小(G)&quot;,        round((c.bytes - d.bytes_used) / 1024 / 1024 / 1024, 2) &quot;临时表空间剩余大小(G)&quot;,        round(d.bytes_used / 1024 / 1024 / 1024, 2) &quot;临时表空间使用大小(G)&quot;,        round(d.bytes_used * 100 / c.bytes, 4) || '%' &quot;使用率 %&quot;   from (select tablespace_name, sum(bytes) bytes           from dba_temp_files          GROUP by tablespace_name) c,        (select tablespace_name, sum(bytes_cached) bytes_used           from v$temp_extent_pool          GROUP by tablespace_name) d  where c.tablespace_name = d.tablespace_name;</code></p>\n<p>–查询表空间位置<br>\n <code>SELECT TABLESPACE_NAME &quot;表空间名&quot;, BYTES/1024/1024 &quot;表空间大小(M)&quot;, FILE_NAME &quot;文件路径&quot;,FILE_ID &quot;文件ID&quot; FROM DBA_DATA_FILES order by TABLESPACE_NAME,FILE_NAME; </code></p>\n<p>扩容：<br>\n–一个表空间最大为 32g，超过 32g 需要增加，例如：</p>\n<pre><code>alter tablespace DAS ADD  datafile '/mc_data/oradata/zsk/das01.dbf' SIZE 30G;\n</code></pre>\n<p>扩展阅读：</p>\n<p>删除表空间扩容文件:</p>\n<pre><code>#alter tablespace 表空间名称 drop datafile 文件id;\nalter tablespace UNDOTBS1 drop datafile 6;\n</code></pre>\n<p>删除临时表空间扩容文件:</p>\n<pre><code>#alter tablespace 临时表空间名称 drop tempfile 文件id;\nalter tablespace UNDOTBS2 drop tempfile 7;\n</code></pre>\n<p>清理表空间：</p>\n<pre><code>alter  tablespace  IRFS_TEMP shrink space;\n</code></pre>\n<p>创建各种类型表空间：</p>\n<pre><code>-- 创建大小为50mb的永久表空间TEST01，禁止自动扩展数据文件\ncreate tablespace TEST01\nlogging\ndatafile'F:\\app\\oraclezq\\oradata\\orcl\\TEST01.dbf' size 50m\nreuse autoextend off;\n\n-- 创建永久表空间TEST02，允许自动扩展数据文件，本地管理方式\ncreate tablespace TEST02\nlogging\ndatafile'F:\\app\\oraclezq\\oradata\\orcl\\TEST02.dbf' size 50m\nreuse autoextend on next 10m maxsize 200m\nextent management local;\n\n-- 创建永久表空间TEST03，允许自动扩展数据文件，本地管理方式，区分配方式为自动分配\ncreate tablespace TEST03\nlogging\ndatafile'F:\\app\\oraclezq\\oradata\\orcl\\TEST03.dbf' size 50m\nreuse autoextend on next 10m maxsize 200m\nextent management local autoallocate;\n\n-- 创建永久表空间TEST04，允许自动扩展数据文件，本地管理方式，区分配方式为定制分配\ncreate tablespace TEST04\nlogging\ndatafile'F:\\app\\oraclezq\\oradata\\orcl\\TEST04.dbf' size 50m\nreuse autoextend on next 10m maxsize 200m\nextent management local uniform size 10m;\n\n-- 创建永久表空间TEST05，允许自动扩展数据文件，本地管理方式，区分配方式为自动分配，段管理方式为自动管理\ncreate tablespace test05\nlogging\ndatafile'F:\\app\\oraclezq\\oradata\\orcl\\TEST05.dbf' size 50m\nreuse autoextend on next 10m maxsize 200M\nextent management local autoallocate\nsegment space management auto;\n\n-- 创建永久表空间TEST06，允许自动扩展数据文件，本地管理方式，区分配方式为定制分配，段管理方式为手动管理\ncreate tablespace test06\nlogging\ndatafile'F:\\app\\oraclezq\\oradata\\orcl\\TEST06.dbf' size 50m\nreuse autoextend on next 10m maxsize 200M\nextent management local uniform size 10m\nsegment space management manual;\n</code></pre>\n<p>扩容 oracle 表空间的四种方法</p>\n<p>示例 1：新增数据文件<br>\n ALTER TABLESPACE DSA ADD DATAFILE ‘E:\\ORACLE\\PRODUCT\\10.2.0\\ORADATA\\DAS01.DBF’ SIZE 102400M;</p>\n<p>示例 2：新增数据文件，允许数据文件自动增长<br>\n ALTER TABLESPACE DSA ADD DATAFILE ‘E:\\ORACLE\\PRODUCT\\10.2.0\\ORADATA\\DSA01.DBF’ SIZE 50M AUTOEXTEND ON NEXT 5M MAXSIZE 100M;</p>\n<p>示例 3：允许已存在的数据文件自动增长<br>\n ALTER DATABASE DATAFILE ‘E:\\ORACLE\\PRODUCT\\10.2.0\\ORADATA\\DSA01.DBF’ AUTOEXTEND ON NEXT 5M MAXSIZE 100M;</p>\n<p>示例 4：手工改变已存在数据文件的大小<br>\n ALTER DATABASE DATAFILE ‘D:\\ORACLE\\PRODUCT\\10.2.0\\ORADATA\\DSA01.DBF’ RESIZE 100M;</p>\n",
            "tags": [
                "数据库"
            ]
        },
        {
            "id": "https://wandana123.github.io/2024/07/24/sql%E3%81%AEupdate-case-when-%E7%9A%84%E7%8E%A9%E6%B3%95/",
            "url": "https://wandana123.github.io/2024/07/24/sql%E3%81%AEupdate-case-when-%E7%9A%84%E7%8E%A9%E6%B3%95/",
            "title": "sqlのupdate case when 的玩法",
            "date_published": "2024-07-24T01:23:36.000Z",
            "content_html": "<p>业务场景：</p>\n<pre><code>有部分数据需要按条件做判断来update某个表的字段值。这个我是怎么实现的呢？\n</code></pre>\n<p>sql：</p>\n<pre><code>UPDATE user \nSET order = CASE\nWHEN id = '1' THEN '1' \nWHEN id = '2' THEN '2' \nEND;\n</code></pre>\n<p>当然，这个语句还可以扩展一下，例如如下用法：</p>\n<pre><code>示例1：\nUPDATE graduates \nSET income = CASE\nWHEN income = 20000 THEN income * 0.5 \nWHEN income = 15000 THEN income + 500 \nELSE income \nEND;\n\n示例2：\nUPDATE customers\nSET age = CASE \nWHEN age &lt; 30 THEN age + 1\nELSE age\nEND;\n\n示例3：\nUPDATE customers\nSET \nage = CASE \n    WHEN city = 'New York' THEN age + 1\n    ELSE age\nEND,\ncountry = CASE \n    WHEN city = 'New York' THEN 'USA'\n    ELSE country\nEND;</code></pre>\n",
            "tags": [
                "数据库"
            ]
        },
        {
            "id": "https://wandana123.github.io/2024/06/26/%E7%A5%9E%E9%80%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%E6%9F%90%E4%B8%AA%E6%A8%A1%E5%BC%8F%E4%B8%8B%E6%89%80%E6%9C%89%E8%A1%A8%E7%9A%84%E5%A4%A7%E5%B0%8F/",
            "url": "https://wandana123.github.io/2024/06/26/%E7%A5%9E%E9%80%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%E6%9F%90%E4%B8%AA%E6%A8%A1%E5%BC%8F%E4%B8%8B%E6%89%80%E6%9C%89%E8%A1%A8%E7%9A%84%E5%A4%A7%E5%B0%8F/",
            "title": "神通数据库查询某个模式下所有表的大小",
            "date_published": "2024-06-26T02:53:38.000Z",
            "content_html": "<p>业务场景：<br>\n有一天正常巡检发现数据库数据量在成倍增长。按道理，我的业务量，数据不可能会这么疯狂的增量。所以想看看到底是啥数据占用了这么多空间。检查发现有张表里写了文件导致的。</p>\n<pre><code>下面是具体sql。\n</code></pre>\n<p><code>SELECT TMP.NSPNAME AS &quot;Sechma&quot;,        TMP.RELNAME,        SUM(TMP.SIZE) / 1024 /1024 AS &quot;Size(M)&quot;   FROM (SELECT N.NSPNAME, C.RELNAME,c.RELKIND, S.SIZE           FROM V_SEGMENT_INFO S, SYS_CLASS C, SYS_NAMESPACE N          WHERE S.RELID = C.OID            AND C.RELNAMESPACE = N.OID) TMP  WHERE  (TMP.NSPNAME='SYSDBA') and TMP.RELKIND ='r'  GROUP BY TMP.NSPNAME, TMP.RELNAME;</code></p>\n<h1 id=\"搞定收工\"><a class=\"markdownIt-Anchor\" href=\"#搞定收工\">#</a> 搞定，收工！！！</h1>\n<h1 id=\"打卡下班\"><a class=\"markdownIt-Anchor\" href=\"#打卡下班\">#</a> 打卡，下班！！！</h1>\n",
            "tags": [
                "数据库"
            ]
        }
    ]
}